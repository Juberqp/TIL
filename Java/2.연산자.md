# 연산자

## 부호/증감 연산자
|연산식||설명|
|--|-|-|
|+|피연산자|피연산자 부호 유지|
|-|피연산자|피연산자 부호 변경|

* char의 경우 -값이 존재하지 않아 음수 표현 불가.

#### 증감 연산자
|연산식|   |설명|
|-|-|-|
|++|피연산자|피연산자 값을 1 증가 (전위)|
|--|피연산자|피연산자 값을 1 감소 (후위)|
|피연산자|++|현재 값을 사용한 뒤, 피연산자 값 1 증가|
|피연산자|--|현재 값을 사용한 뒤, 피연산자 값 1 감소|

* 증감 연산자가 앞에 있으면 즉시 1 증가/감소 후 계산.
* 증감 연산자가 피연산자 뒤에 있으면 계산 수 1 증가/감소.

## 산술 연산자
|연산식|||설명|
|-|-|-|-|
|피연산자|+|피연산자|덧셈
|피연산자|-|피연산자|뺄셈
|피연산자|*|피연산자|곱셈
|피연산자|/|피연산자|나눗셈
|피연산자|%|피연산자|나눗셈의 나머지

* 피연산자가 byte, short, char, int 라면 연산 결과는 int
* 피연산자 중 하나가 long이라면 연산 결과는 long
* 피연산자 중 하나가 실수(float, double)이라면 연산 결과는 double

## 오버플로우와 언더 플로우
* 오버플로우는 타입의 최대 값을 벗어나는 것
* 언더플로우는 타입의 최소 값을 벗어나는 것

```
byte a = 127;  

a += 1;  
System.out.println(a); //-128이 된다.
```

## 정확한 계산은 정수로
* 실수 타입으로 계산하면 부동 소수점 방식 때문에 값이 틀어진다.
* 정수로 계산 후 실수로 변환하는 것이 안전.

## 나눗셈 연산 후 NaN과 Infinity 처리
* / 또는 % 연산에서 우측피연산자가 0 일 경우 무한대 값을 정수로 표현할 수 없어 예외가 발생한다.

> 5 / 0 // 예외 발생, 무한대 값  
> 5 % 0 // 예외 발생, 나머지 없음  

* 하지만 우측 피연산자가 실수라면 예외가 발생하지 않고 무한대 또는 NaN이 된다.

> 5 / 0.0 = Infinity
> 5 % 0.0f = NaN

* 때문에 / 와 % 의 연산 결과를 먼저 확인하는 것이 좋다.

> Double.isInfinity(변수);
> Double.isNaN(변수);

## 비교 연산자
|구분|연산식|||설명|
|-|-|-|-|-|
|동등 비교|피연산자1|==|피연산자2|두 피연산자의 값이 같은지 검사|
|동등 비교|피연산자1|!=|피연산자2|두 피연산자의 값이 다른지 검사|
|크기 비교|피연산자1|>|피연산자2|피연산자1이 큰지 검사|
|크기 비교|피연산자1|>=|피연산자2|피연산자1이 크거나 같은지 검사|
|크기 비교|피연산자1|<|피연산자2|피연산자1이 작은지 검사|
|크기 비교|피연산자1|<=|피연산자2|피연산자1이 작거나 같은지 검사|

* 타입이 다를 경우 먼저 더 큰 타입으로 변환한 다음 검사한다.
* 다만 실수의 경우 float가 정확도가 더 떨어져서 double로 변환되면서 손실이 일어나기 때문에 false가 출력된다.
* 그러므로 double을 float로 강제 타입 변환 후 비교해야 정확하다.
  
## 논리 연산자
|구분|연산식|||설명|
|-|-|-|-|-|
|AND(논리곱)|피연산자|&& 또는 &|피연산자|피연산자 모두가 true 시 true|
|OR(논리합)|피연산자|\|\| 또는 \||피연산자|피연산자 하나라도 true 시 true|
|XOR(배타적 논리합)|피연산자|^|피연산자|두 피연산자가 서로 다를 때 true|
|NOT(논리부정)||!|피연산자|피연산자의 논리값을 바꿈|

#### &&와 &, ||와 | 차이
> &&: 앞 피연산자가 false라면 뒤를 고려하지 않고 바로 false  
> &: 앞, 뒤 피연산자를 모두 평가하여 산출함

> ||: 앞 피연산자가 true라면 뒤를 고려하지 않고 바로 true  
> |: 앞, 뒤 피연산자를 모두 평가하여 산출함

* 보통 &&, || 를 사용하는게 효율적이다.
* & 나 | 는 비트 연산자, 반드시 둘다 체크 되어야 하는 값에 사용.

## 비트 연산자
|구분|연산식|||설명|
|-|-|-|-|-|
|AND(논리곱)|비트|&|비트|두 비트 모두 1일 경우 연산 결과 1|
|OR(논리합)|비트|\||비트|두 비트 중 하나라도 1일 경우 연산 결과 1|
|XOR(배타적 논리합)|비트|^|비트|두 비트가 다를 때 true|
|NOT(논리 부정)||~|비트|보수(1->0, 0->1)|

#### 논리곱
> 00101101  
> &  
> 00011001  
> =00001001  

#### 논리합
> 00101101  
> |  
> 00011001  
> =00111101  

#### 배타적 논리합
> 00101101  
> ^  
> 00011001  
> =00110100  

#### 논리 부정
> ~  
> 00101101  
> =11010010  

## 비트 이동 연산자
|구분|연산식|||설명|
|-|-|-|-|-|
||a|<<|b|정수 a의 각 비트를 b만큼 왼쪽 이동, 빈자리는 0으로 채움|
|이동(shift)|a|>>|b|정수 a의 각 비트를 b만큼 오른쪽 이동, 왼쪽 빈자리는 최상위 부호 비트와 같은 값으로 채움|
||a|>>>|b|정수 a의 각 비트를 b만큼 오른쪽 이동, 빈자리는 0으로 채움|

#### << 비트 연산
> 00000000 00000000 00000000 00000001  
> a << 3  
> 00000000 00000000 00000000 00001000  

#### >> 비트 연산
> 11111111 11111111 11111111 11111000  
> a >> 3  
> 11111111 11111111 11111111 11111111  

#### >>> 비트 연산
> 11111111 11111111 11111111 11111000  
> a >>> 3  
> 00011111 11111111 11111111 11111111

#### \>\> 와 \>\>\> 의 차이
* 비트의 최상위 부호는 값이 양수인지 음수인지를 나타낸다. 최상위 부호가 1이면 음수, 0이면 양수.
* \>\> 비트 연산은 값의 부호 유지
* \>\>\> 비트 연산은 값의 부호 무시

## 대입 연산자
|구분|연산식|||설명|
|-|-|-|-|-|
|단순 대입 연산자|변수|=|피연산자|변수 = 피연산자|
|복합 대입 연산자|변수|+=|피연산자|변수 = 변수 + 피연산자|
|복합 대입 연산자|변수|-=|피연산자|변수 = 변수 - 피연산자|
|복합 대입 연산자|변수|*=|피연산자|변수 = 변수 * 피연산자|
|복합 대입 연산자|변수|/=|피연산자|변수 = 변수 / 피연산자|
|복합 대입 연산자|변수|%=|피연산자|변수 = 변수 % 피연산자|
|복합 대입 연산자|변수|&=|피연산자|변수 = 변수 & 피연산자|
|복합 대입 연산자|변수|\|=|피연산자|변수 = 변수 ! 피연산자|
|복합 대입 연산자|변수|^=|피연산자|변수 = 변수 ^ 피연산자|
|복합 대입 연산자|변수|<<=|피연산자|변수 = 변수 << 피연산자|
|복합 대입 연산자|변수|>>=|피연산자|변수 = 변수 >> 피연산자|
|복합 대입 연산자|변수|>>>=|피연산자|변수 = 변수 >>> 피연산자|

## 삼항(조건) 연산자
* 3개의 피연산자를 가진다.
* ? 앞 피연산자에 boolean 변수 또는 조건식이 오므로 조건 연산자라고도 한다.

> (조건식) ? (값 또는 연산식1) : (값 또는 연산식2)  
>
> 조건식이 true 일시 (값 또는 연산식1)  
> 조건식이 false 일시 (값 또는 연산식2)  

## 연산 방향과 우선순위
|연산자|연산 방향|우선 순위|  
|-|-|-|
|증감(++, --), 부호(+, -), 비트(~), 논리(!)|<----|높음|  
|산술(*, /, %)|---->||  
|산술(+, -)|---->|| 
|쉬프트(<<, >>, >>>)|---->||  
|비교(<, >, <=, >=, instanceof)|---->||  
|비교(==, !=)|---->||  
|논리(&)|---->||  
|논리(^)|---->||  
|논리(\|)|---->||  
|논리(&&)|---->||  
|논리(\|\|)|---->||  
|조건(?:)|---->||  
|대입(=, +=, -=, *=, /=, %=, &=, ^=, !=, <<=, >>=, >>>=)|<----|낮음|  
